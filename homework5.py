# Yuori Sidortsov
# Homework-5
# 24-03-2024
# Grodno-IT-Academy-Python 3.11.5

import re

# Реализовать функцию get_ranges которая получает на вход непустой список неповторяющихся целых чисел,
# отсортированных по возрастанию, которая этот список “сворачивает”.
# get_ranges([0, 1, 2, 3, 4, 7, 8, 10])  #  "0-4, 7-8, 10"
# get_ranges([4,7,10])  # "4, 7, 10"
# get_ranges([2, 3, 8, 9])  # "2-3, 8-9"

# Задача_1

def get_ranges(lst):
# если в списке lst отсутствуют элементы, возвращаем пустую строку
    if not lst:
        return ""
# создаем пустой список и пустую строку для хранения значений:
    new_lst = []
    new_str = ""
# создаем 2 временные переменные равные 1 элементу введенного списка
    first = last = lst[0]  
# итерируемся по введенному списку начиная со 2 элемента
    for i in lst[1:]:
# проверяем условие равен ли элемент i значению следующего элемента
        if i == last + 1:
# если равен присваиваем переменной last значение элемента i
            last = i
# если нет добавляем в новый список 1 и последний элемент
        else:
            new_lst.append((first, last))
# присваиваем значение последнего элемента временным переменным
            first = last = i
# добавляем в новый список последние элементы
    new_lst.append((first, last))
# объявляем временную переменную
    count = 0
# итерируемся по новому списку для вывода данных в виде строки
    for i, j in new_lst:
# проверяем условие чтобы элемент списка не был последним, повторяющимся и был первым элементом списка
        if i != j and new_lst[0] == i:
# при выполнении условия выполняем операции со строкой 
            new_str = str(i) + "-" + str(j) + "," + " "
# проверяем условие чтобы элемент списка не был последним
        elif i != j:
# при выполнении условия выполняем операции со строкой 
            new_str = new_str + str(i) + "-" + str(j) + "," + " "
# если ни одно условие не выполнилось, проверяем: 
        else:
# проверяем условие последний это элемент или нет, если нет приравниваем count к 1            
            if count == 0:
                count = 1
# при выполнении условия выполняем операции со строкой 
                new_str += str(j)
            else:
# при выполнении условия выполняем операции со строкой 
                new_str = new_str + ", " + str(j)
# удаляем лишнею запятую в конце строки при ее наличии
    new_str = new_str.strip(" ,") 
    return new_str

# Напсать функцию standardise_phones которая принимает любое
# количество нестандартизированных телефонных номеров и возвращает
# список стандартизированных номеров в том порядке в котором они были
# введены. А если число не является номером - возвращает пустой список
# standardise_phones("298884455") # ["+375298884455"]
# standardise_phones(*args) # ["+375298884455","+375298885555","+375299998877","+375299998867"]
# standardise_phones("298884asd45") # []
# args = ["+375298884455","+375298885555","+375299998877","+375299998867","434343555"]
# args = ["+375298884455","80298885555","+375299998877","+375299998867","434343555"]
# def standardise_phones(*args):

# Задача_2

def standardise_phones(*args):
# создаем пустой список для хранения номеров
    lst = []
# запускаем цикл для итерирования по введенным номерам
    for num in args:
# приводим каждый номер к типу данных строка
        num = str(num)
# проверяем условие что в номере отсутствует буква, с помощью функции match , библиотеки re
# при выполнении условия пропускаем номер
        if re.match(r'[a-z]|[A-Z]', num):
            continue
# проверяем условие что в начале номера присутствуют коды(29,17,33,44) и после них не меньше 7 цифр
# при выполнении добавляем в начало номера +375 и добавляем номер в список хранения номеров
        elif re.match(r'^(29|17|33|44)\d{7}', num):
            num = "+375" + num
            lst.append(num)
# проверяем условие что номер является номером в формате рб 
# при выполнении добавляем добавляем номер в список хранения номеров
        elif re.match(r'\+375\d{9}', num):
            lst.append(num)
# проверяем условие что в начале номера присутствуют коды(80 или 375) и после не меньше 9 цифр
# при выполнении с помощью ф-ции sub библиотеки re заменяем 80 или 375 на +375 и добавляем номер в список
        elif re.match(r'^(80|375)(\d{9})', num):
            num = re.sub(r'^(80|375)', r'+375', num)
            lst.append(num)
    return lst
    
# Задача_3

# Создайте декоратор handle_multiples который позволит функции rope_product
# вернуть лиш один ответ если задано одно число и много ответов списком если
# введённых значений будет несколько! И добавьте его к функции rope_product
# не меняя решения из предыдущего решения!
# rope_product(8) -> 18
# rope_product(7,11,23,45,32) -> [12, 54, 4374, 14348907, 118098]
# здесь можно пользоваться циклами
# создаем декоратор 
def handle_multiples(func):
    def wrapper(*args):
# проверяем условие если декорируемая функция вызывается с одним аргументом
        if len(args) == 1:
# то декоратор вызывает функцию и возвращает результат
            return func(args[0])
# еcли декорируемая функция вызывается с несколькими аргументами
        else:
# то применяем ф-цию map для перебора всех значений args и приобразуем к списку
            return list(map(func, args))
    return wrapper

# Создайте функцию rope_product, которая берёт позитивный цельный номер,
# который представляет собой длину верёвки. Длина этой
# верёвки может быть разделена на любое количество более
# малых цельных чисел. Верните максимальный продукт умножения
# малых цельных чисел. Решение не должно пользоваться циклами!

# используем декоратор к функции rope_product
@handle_multiples
def rope_product(n):
# проверяем условие что n не меньше 4 в противном случае возвращаем n, так веревка меньше чем на 3 не режется
    if n < 4:
        return n
# проверяем условие что n больше 4 
    elif n > 4:
# используем рекурсивную функцию, так как по условию задачи цикл применять нельзя
# вызываем функцию rope_product с новым аргументом n - 3 что соответствует разрезанию веревки длиной n на часть длиной 3 и остаток длиной n - 3
# умножаем результат этого вызова на 3, что соответствует вычислению произведения длин частей веревки
# получаем максимальное произведение длин частей веревки
        return 3 * rope_product(n - 3)
    return n

# # rope_product(1) -> 1
# # rope_product(4) -> 4
# # rope_product(5) -> 6
# # rope_product(6) -> 9
# # rope_product(7) -> 12
# # rope_product(11) -> 54
# @handle_multiples
# def rope_product(n):
#     return

# # создаем декоратор 
# def handle_multiples(func):
#     def wrapper(*args):
# # проверяем условие если декорируемая функция вызывается с одним аргументом
#         if len(args) == 1:
# # то декоратор вызывает функцию и возвращает результат
#             return func(args[0])
# # еcли декорируемая функция вызывается с несколькими аргументами
#         else:
# # то применяем ф-цию map для перебора всех значений args и приобразуем к списку
#             return list(map(func, args))
#     return wrapper
# # используем декоратор к функции rope_product
# @handle_multiples
# def rope_product(n):
# # проверяем условие что n не меньше 4 в противном случае возвращаем n, так веревка меньше чем на 3 не режется
#     if n < 4:
#         return n
# # проверяем условие что n больше 4 
#     elif n > 4:
# # используем рекурсивную функцию, так как по условию задачи цикл применять нельзя
# # вызываем функцию rope_product с новым аргументом n - 3 что соответствует разрезанию веревки длиной n на часть длиной 3 и остаток длиной n - 3
# # умножаем результат этого вызова на 3, что соответствует вычислению произведения длин частей веревки
# # получаем максимальное произведение длин частей веревки
#         return 3 * rope_product(n - 3)
#     return n
